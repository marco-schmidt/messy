buildscript {
  repositories {
    mavenCentral()
  }
}

plugins {
  alias(libs.plugins.dependencylicensereport)
  alias(libs.plugins.dependencycheck)
  alias(libs.plugins.forbiddenapis)
  alias(libs.plugins.spotbugs)
  alias(libs.plugins.spotless)
  alias(libs.plugins.ver)
  id 'jacoco'
}

repositories {
  mavenLocal()
  mavenCentral()
}

ext.vendorlibs = [
  commons_compress: 'org.apache.commons:commons-compress:1.21',
  jakarta_mail: 'com.sun.mail:jakarta.mail:2.0.1',
  json_smart: 'net.minidev:json-smart:2.4.7',
  junit: 'junit:junit:4.13.2',
  logback_classic: "ch.qos.logback:logback-classic:1.2.6",
  slf4j_api: "org.slf4j:slf4j-api:1.7.32"
]

description 'a tool suite for electronic messages'
defaultTasks 'clean', 'check', 'allJavadoc', 'installDist', 'distTar', 'distZip', 'generateLicenseReport', 'codeCoverageReport'
ext.licenseName = 'The Apache Software License, Version 2.0'

// version is stable if it contains only numerical parts or a 'stable keyword'
def isStable = { String version ->
  def stableKeyword = ['RELEASE', 'FINAL', 'GA'].any { it -> version.toUpperCase(Locale.ENGLISH).contains(it) }
  def regex = /^[0-9,.v-]+(-r)?$/
  return stableKeyword || (version ==~ regex)
}

dependencyUpdates {
  rejectVersionIf {
    !isStable(it.candidate.version)
  }
  outputDir = "${buildDir}/reports/dependencyUpdates"
}

def retrieveGitModification = { ->
  def baos = new ByteArrayOutputStream()
  exec {
    commandLine 'git', 'diff', '--shortstat'
    standardOutput = baos
  }
  return baos.toString().trim()
}

def retrieveGitRevision = { ->
  def baos = new ByteArrayOutputStream()
  exec {
    commandLine 'git', 'rev-parse', 'HEAD'
    standardOutput = baos
  }
  return baos.toString().trim()
}
rootProject.ext.revision = retrieveGitRevision()
rootProject.ext.modified = retrieveGitModification()
rootProject.ext.modified = !(rootProject.ext.modified == null || rootProject.ext.modified.trim().length() == 0)

def timeZone = java.util.TimeZone.getTimeZone(java.time.ZoneOffset.UTC)
def dateFormatter = new java.text.SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ssZ", java.util.Locale.ENGLISH)
dateFormatter.setTimeZone(timeZone)
rootProject.ext.now = dateFormatter.format(new Date())
rootProject.ext.gradleVersion = getProject().getGradle().getGradleVersion()

subprojects {
  repositories {
    mavenLocal()
    mavenCentral()
  }

  apply plugin: 'checkstyle'
  apply plugin: 'eclipse'
  apply plugin: 'jacoco'
  apply plugin: 'java'
  apply plugin: 'maven-publish'
  apply plugin: 'com.diffplug.spotless'
  apply plugin: 'com.github.jk1.dependency-license-report'
  apply plugin: 'com.github.spotbugs'

  tasks.withType(JavaCompile) {
    sourceCompatibility = JavaVersion.VERSION_1_8
    targetCompatibility = sourceCompatibility
    options.debugOptions.debugLevel = 'lines,vars,source'
    options.encoding = java.nio.charset.StandardCharsets.UTF_8
    options.warnings = true
    options.deprecation = true
    options.compilerArgs += ['-Xlint:all', '-Werror']
  }

  task createPomProperties() {
    description "create a text file to be included in the jar to make it self-describing"
    doLast {
      new File(buildDir, "pom.properties").text = """version=${version}
groupId=${project.group}
artifactId=${project.name}
"""
    }
  }

  jar {
    manifest {
      attributes(
        'Implementation-Title': project.name,
        'Implementation-Version': project.version,
        'Implementation-URL': 'https://github.com/marco-schmidt/messy/',
        'Automatic-Module-Name': "${project.group}.${project.name}",
        'Created-By': 'Gradle ' + rootProject.ext.gradleVersion,
        'Build-Date': rootProject.ext.now,
        'License': rootProject.ext.licenseName,
        //'Main-Class': mainClassName,
        'Java-Version': targetCompatibility,
        'Git-Revision': rootProject.ext.revision,
        'Git-Modified': rootProject.ext.modified
        //,        'Class-Path': configurations.runtimeClasspath.collect { it.getName() }.join(' ')
        )
    }
    from ('..') {
      include 'LICENSE'
      into 'META-INF'
    }
    into("META-INF/maven/${project.group}/${project.name}") {
      from { generatePomFileForLibraryPublication }
      rename ".*", "pom.xml"
    }
    from (buildDir) {
      include 'pom.properties'
      into "META-INF/maven/${project.group}/${project.name}"
    }
  }
  jar.dependsOn createPomProperties

  javadoc {
    options {
      windowTitle = "${project.name} ${project.version} API documentation"
      docTitle = '<a target="_top" href="https://github.com/marco-schmidt/messy">messy ' + project.version + '</a>'
      linksOffline 'https://docs.oracle.com/javase/8/docs/api/', "${rootDir}/config/javadoc/"
    }
  }

  task packageJavadoc(type: Jar, dependsOn: 'javadoc') {
    from javadoc.destinationDir
    classifier = 'javadoc'
  }

  task packageSources(type: Jar, dependsOn: 'classes') {
    from sourceSets.main.allSource
    classifier = 'sources'
  }

  task packageLicenseReport(type: Zip, dependsOn: 'generateLicenseReport') {
    description "create a zip archive with license report information"
    from licenseReport.outputDir
    classifier = 'deplicensereport'
  }

  // https://github.com/diffplug/spotless
  spotless {
    java {
      licenseHeaderFile "${rootDir}/config/spotless/license-header.txt"
      removeUnusedImports()
      trimTrailingWhitespace()
      eclipse().configFile "${rootDir}/config/eclipse/formatter.xml"
    }
  }

  licenseReport {
    allowedLicensesFile = new File("$rootDir/config/licenseReport/allowed-licenses.json")
  }
  check.dependsOn checkLicense

  forbiddenApis {
    bundledSignatures = ['jdk-system-out', 'jdk-unsafe', 'jdk-internal',
    'jdk-deprecated', 'jdk-non-portable', 'jdk-reflection' ]
    // https://jenkins.thetaphi.de/job/Forbidden-APIs/javadoc/signatures-syntax.html
    signaturesFiles = files("${rootDir}/config/forbiddenApis/signatures.txt")
    ignoreFailures = false
  }

  jacoco {
    toolVersion = libs.versions.jacoco.get()
  }

  jacocoTestReport {
    reports {
      html.destination file("${buildDir}/reports/jacoco")
    }
  }
  jacocoTestCoverageVerification {
    violationRules {
      rule {
        limit {
          minimum = 0.0
        }
      }
    }
    dependsOn test
  }
  jacocoTestReport.dependsOn jacocoTestCoverageVerification
  check.dependsOn jacocoTestCoverageVerification

  task packageCoverageReport(type: Zip, dependsOn: 'jacocoTestReport') {
    description "create a zip archive with coverage report information"
    from jacocoTestReport.reports.html.entryPoint
    classifier = 'coveragereport'
  }

  spotbugs {
    toolVersion = libs.versions.spotbugs.get()
    effort = 'max' // min, default, max
    reportLevel = 'low' // low, medium, high  
    ignoreFailures = false
    excludeFilter = file("${rootDir}/config/spotbugs/excludeBugsFilter.xml")
  }

  tasks.withType(com.github.spotbugs.snom.SpotBugsTask) {
    reports {
      xml.enabled = false
      html.enabled = true
      html.stylesheet resources.text.fromFile("${rootDir}/config/spotbugs/report-stylesheet.xsl")
    }
  }

  checkstyle {
    toolVersion libs.versions.checkstyle.get()
    ignoreFailures false
    showViolations true
    configDirectory = file("${rootDir}/config/checkstyle")
  }

  dependencyCheck {
    cveValidForHours=24
    failBuildOnCVSS=0
    suppressionFile=file("${rootDir}/config/dependencyCheck/suppressions.xml")
    analyzers {
      assemblyEnabled=false
    }
  }
  check.dependsOn dependencyCheckAnalyze

  publishing {
    repositories {
      maven {
        name = "GitHubPackages"
        url = uri("https://maven.pkg.github.com/marco-schmidt/messy")
        credentials {
          username = project.findProperty("gpr.user") ?: System.getenv("gpr.user")
          password = project.findProperty("gpr.key") ?: System.getenv("gpr.key")
        }
      }
    }
    publications {
      library(MavenPublication) {
        from components.java
        artifact packageSources
        artifact packageJavadoc
        artifact packageCoverageReport
        artifact packageLicenseReport
        groupId group
        pom.withXml {
        asNode().appendNode('name', project.name)
        asNode().appendNode('url', 'https://github.com/marco-schmidt/messy')
        asNode().appendNode('description', rootProject.description)
        asNode().appendNode('packaging', 'jar')
        asNode().appendNode('inceptionYear', '2020')
        asNode().appendNode('properties').
          appendNode('gitrevision', rootProject.ext.revision).parent().
          appendNode('gitmodified', rootProject.ext.modified).parent().
          appendNode('buildtime', rootProject.ext.now).parent().
          appendNode('gradleversion', rootProject.ext.gradleVersion).parent().
          appendNode('java', targetCompatibility)
        asNode().appendNode('scm').
          appendNode('connection', 'scm:git:git@github.com:marco-schmidt/messy.git').parent().
          appendNode('developerConnection', 'scm:git:git@github.com:marco-schmidt/messy.git').parent().
          appendNode('url', 'https://github.com/marco-schmidt/messy')
        asNode().appendNode('developers').appendNode('developer').
          appendNode('id', 'marco-schmidt').parent().
          appendNode('name', 'Marco Schmidt').parent().
          appendNode('email', 'mschmidtgit@protonmail.com').parent().
          appendNode('organization', 'private').parent().
          appendNode('organizationUrl', 'https://github.com/marco-schmidt')
        asNode().appendNode('licenses').appendNode('license').
          appendNode('name', rootProject.ext.licenseName).parent().
          appendNode('url', 'https://www.apache.org/licenses/LICENSE-2.0.html')
        }
      }
    }
  }
}

task codeCoverageReport(type: JacocoReport)
{
  executionData fileTree(project.rootDir.absolutePath).include("**/build/jacoco/*.exec")

  subprojects.each {
    sourceSets it.sourceSets.main
  }

  reports
  {
    xml.required = true
    xml.destination file("${buildDir}/reports/jacoco/report.xml")
    html.required = true
    csv.required = false
  }
}

codeCoverageReport.dependsOn
{
  subprojects*.test
}

task allJavadoc(type: Javadoc)
{
  source subprojects.collect { it.sourceSets.main.allJava }    											  
  classpath = files(subprojects.collect { it.sourceSets.main.compileClasspath })
  destinationDir = file("${buildDir}/docs/javadoc")
  options
  {
    failOnError = true
    addStringOption('Xdoclint:all')
    outputLevel = JavadocOutputLevel.QUIET // VERBOSE
  }
}
